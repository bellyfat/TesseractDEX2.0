pragma solidity ^0.4.0;
contract MultiSig {
    
    //public fields
    uint epochSize;
    uint claimSize;
    uint withdrawSize;
    uint blockStartNum;
    uint globalCoinCounter;
    State currentState;
    mapping(address => TwoWayChannel) public balances;
    address[] public activeUsers;
    address public tesseract = 0xF21425bbE5e556A490fB2d11774d1788e944B3d3;  //hard code tesseract address
    
    //enum to manage state for each acct
    enum State {Epoch, Claim, Withdraw}
    
    //redeem request definition
    struct ClaimRequest{
        uint globalCoinID;
        uint nonce;
        uint coinVal;
    }
    
    //two-way channel definition (value in contract balance mapping)
    struct TwoWayChannel {
        uint value;
        uint numSplits;
        ClaimRequest[] coins;
    }
    
    //two possible events
    event Deposit(address _sender, uint _value);
    event Claim(address _owner, address _sender, uint _coinID);
    
    //modifier for initiating party -> HARD CODE IN TESSERACT ADDRESS SO CAN'T BE MODIFIED
    modifier onlyInitial() {
        require(
            msg.sender == tesseract,
            "Only Tesseract can call this."
        );
        _;
    }
    
    //contract constructor
    constructor(uint _epochSize, uint _claimSize, uint _withdrawSize) public onlyInitial(){
        epochSize = _epochSize;
        claimSize = _claimSize;
        withdrawSize = _withdrawSize;
        blockStartNum = block.number;
        currentState = State.Epoch;
    }
    
    //deposit function
    function deposit(uint _numSplits) payable public {
        require(determineState() == State.Epoch, "Can only deposit during Epoch phase.");
        activeUsers.push(msg.sender);
        if(msg.value > 0.0){
            balances[msg.sender].value = msg.value;
            balances[msg.sender].numSplits = _numSplits;
            for(uint a=0;a<_numSplits;a++){
                ClaimRequest memory initialCR = ClaimRequest(globalCoinCounter++,0,msg.value/_numSplits);
                balances[msg.sender].coins.push(initialCR);
            }
            emit Deposit(msg.sender, msg.value);
        }
    }
    
    //claim function
    function claim(bytes32 messageFirst, bytes32 messageSecond, uint _coinIndex, uint _globalCoinID, uint _nonce, uint8 claimerFirst, bytes32 claimerSecond, bytes32 claimerThird, uint8 tesseractFirst, bytes32 tesseractSecond, bytes32 tesseractThird) public{
        require(determineState() == State.Claim, "Can only claim during Claim phase.");
        bytes32 hash = cryptoHash(messageFirst, messageSecond,_globalCoinID,_nonce);   //the message components make up the "from" acct, or alice's PK
        address _owner = getAddressFromPK(messageFirst,messageSecond);
        require(verifySigner(_owner, hash, claimerFirst, claimerSecond, claimerThird) == true);     //verify claimer signature
        require(verifySigner(tesseract, hash, tesseractFirst, tesseractSecond, tesseractThird) == true);        //verify tesseract signature
        require(balances[_owner].coins[_coinIndex].globalCoinID == _globalCoinID, "Accessing incorrect coin, check the blockchain as it may have been traded or a user is making malicious claims.");     //verify global coin id matches 
        if(_nonce >balances[_owner].coins[_coinIndex].nonce){
            uint _coinVal = balances[_owner].coins[_coinIndex].coinVal;
            balances[_owner].coins[_coinIndex].coinVal = 0;
            ClaimRequest memory request = ClaimRequest(_globalCoinID, _nonce, _coinVal);
            balances[msg.sender].coins.push(request); 
        }
        emit Claim(_owner, msg.sender, _globalCoinID);
    }
    
    //withdraw function ->callable by anyone and will envoke all withdraws
    function withdraw() public{
        require(determineState() == State.Withdraw, "Can only withdraw during Withdraw phase.");
        for(uint k=0;k<activeUsers.length;k++){     //does the withdrawls for all users
            uint transferAmount = 0;
            for(uint l=0;l<balances[activeUsers[k]].coins.length;l++){
                if(balances[activeUsers[k]].coins[l].coinVal > 0){
                    transferAmount += balances[activeUsers[k]].coins[l].coinVal;
                    balances[activeUsers[k]].value -= transferAmount;
                } 
            }
            if(transferAmount > 0) activeUsers[k].transfer(transferAmount); 
        }
        
        delete activeUsers;     //reset state and clear active users
        currentState = State.Epoch;
        blockStartNum = block.number;
    }
    
    
    //function to determine current global Tesseract state
    function determineState() internal view returns(State theState){
        uint currentBlock = block.number;
        uint cycleSize = epochSize + claimSize + withdrawSize;
        uint cycles = (currentBlock - blockStartNum) % cycleSize;
        if ((currentBlock - (cycles*cycleSize+blockStartNum)) < epochSize){
            return State.Epoch;
        }
        else if ((currentBlock - (cycles*cycleSize+blockStartNum)) < (epochSize+claimSize)){
            return State.Claim;
        }
        else{
            return State.Withdraw;
        }
    }
    
    //function to return sha256 hash of packed encoding
    function cryptoHash(bytes32 messageFirst, bytes32 messageSecond, uint coinID, uint nonce) internal pure returns(bytes32){
        return sha256(abi.encodePacked(messageFirst,messageSecond,coinID,nonce));
    }
    
    //function to verify signer
    function verifySigner(address p, bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns(bool) {
        return ecrecover(hash, v, r, s) == p;
    }
    
    //function to get an address given a public key
    function getAddressFromPK(bytes32 publicKeyFirst, bytes32 publicKeySecond) internal pure returns(address){
        return address(keccak256(abi.encodePacked(publicKeyFirst,publicKeySecond)));
    }
    
    /*
    Modifications:
        -way to fix gas requirement warnings?
        -TEST! TEST! TEST!
        -record gas usage for measurements in report, could do graph showing numSplits by gas usage
    */

}